--таблица для хранения котировок индекса
DROP TABLE RTS_QUOTE;
CREATE TABLE RTS_QUOTE
(RTS_TICKER VARCHAR2(50),
 RTS_PER NUMBER(4,0),
 RTS_DATE VARCHAR2(10) INVISIBLE,
 RTS_TIME VARCHAR2(10) INVISIBLE,
 RTS_DATETIME TIMESTAMP,
 RTS_OPEN NUMBER(8,0),
 RTS_HIGH NUMBER(8,0),
 RTS_LOW NUMBER(8,0),
 RTS_CLOSE NUMBER(8,0),
 RTS_VOL NUMBER(8,0));

 --динамически добавляем timestamp полностью 
CREATE OR REPLACE TRIGGER RTS_QUOTE_TRIGGER
BEFORE INSERT ON RTS_QUOTE
FOR EACH ROW
BEGIN  
    :NEW.RTS_DATETIME := NVL(:NEW.RTS_DATETIME, TO_TIMESTAMP(:NEW.RTS_DATE || ' ' || :NEW.RTS_TIME, 'YYYY-MM-DD HH24:MI:SS'));
END;
/

--все необходимые типы
DROP TYPE ANALYTICS_TABLE;
DROP TYPE ANALYTICS_ROW;
CREATE TYPE ANALYTICS_ROW AS OBJECT (DATETIME TIMESTAMP, PRICE NUMBER, EMA NUMBER);
/
CREATE TYPE ANALYTICS_TABLE AS TABLE OF ANALYTICS_ROW;
/

--конвейерная функция, возвращающая для каждого timestamp среднюю цену и взвешенное скользящее среднее
CREATE OR REPLACE FUNCTION GET_ANALYTICS_TABLE
RETURN ANALYTICS_TABLE PIPELINED 
IS 
    EMA NUMBER; N NUMBER; SF NUMBER; PRICE NUMBER;
BEGIN 
    EMA := 0; N := 0;
    FOR REC IN (SELECT * FROM RTS_QUOTE ORDER BY RTS_DATETIME) LOOP 
        PRICE := (REC.RTS_OPEN + REC.RTS_HIGH + REC.RTS_LOW + REC.RTS_CLOSE) / 4;
        N := N + 1;
        SF := 2 / (N + 1);
        EMA := SF * PRICE + (1 - SF) * EMA; 
        PIPE ROW(ANALYTICS_ROW(REC.RTS_DATETIME, PRICE, EMA)); 
    END LOOP; 
    RETURN; 
END; 
/

--запрос для приложения
SELECT TO_CHAR(RTS_DATETIME, 'HH24:MI') AS "TIME",
    RTS_OPEN AS "OPEN",
    RTS_HIGH AS "HIGH",
    RTS_LOW AS "LOW",
    RTS_CLOSE AS "CLOSE"
FROM RTS_QUOTE
